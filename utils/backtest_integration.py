# backtest_integration.py
import os
import pandas as pd
import numpy as np
from datetime import datetime
import logging
import Z_config

logger = logging.getLogger('backtest_integration')
logger.setLevel(logging.INFO)
handler = logging.StreamHandler()
handler.setFormatter(logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s'))
logger.addHandler(handler)

if not os.path.exists("./trades"):
    os.makedirs("./trades")


def analyze_backtest_results(results):
    """
    Analyze and print detailed backtest results.
    Expects 'results' dict generated by the updated calculate_performance_metrics.

    Args:
        results (dict): Backtest results dictionary containing metrics and trade list.
    """
    print("\n" + "="*50)
    print("BACKTEST RESULTS ANALYSIS")
    print("="*50)

    # --- Basic Info ---
    # Use .get() with defaults for safety
    print(f"Initial Balance: ${results.get('initial_balance', 0.0):.2f}")
    print(f"Final Balance: ${results.get('final_balance', 0.0):.2f}") # Note: final_balance might be based on start + summed PnL
    print(f"Total Profit: ${results.get('total_profit', 0.0):.2f} ({results.get('total_profit_pct', 0.0):.2f}%)")
    print(f"Maximum Drawdown: {results.get('max_drawdown_pct', 0.0):.2f}%")
    print(f"Total Trades (Exit Events): {results.get('total_trades', 0)}") # Changed label for clarity

    total_trades_count = results.get('total_trades', 0)

    # --- Core Metrics (Check if trades exist) ---
    if total_trades_count > 0:
        # Handle potential float('inf') for profit factor
        profit_factor = results.get('profit_factor', 0.0)
        pf_display = f"{profit_factor:.2f}" if np.isfinite(profit_factor) else "inf"

        print(f"Win Rate: {results.get('win_rate', 0.0)*100:.2f}%") # Calculated based on non-BE trades
        print(f"Profit Factor: {pf_display}")
        print(f"Average PnL per Winning Event: ${results.get('avg_profit_win', 0.0):.4f}")
        print(f"Average PnL per Losing Event: ${results.get('avg_loss_loss', 0.0):.4f}") # This should be negative
        print(f"Overall Average PnL per Event: ${results.get('avg_profit', 0.0):.4f}") # Overall average

        # --- Exit Reason Analysis (FIXED) ---
        print("\nExit Reason Analysis:")
        exit_reasons_data = results.get('exit_reasons')
        if isinstance(exit_reasons_data, dict) and exit_reasons_data:
            # Use total_trades_count (which is total events) for percentage calculation
            for reason, count in exit_reasons_data.items():
                 # 'count' IS the integer value from the Counter dictionary
                 if isinstance(count, int) and count > 0:
                     percentage = (count / total_trades_count) * 100
                     # Avg P&L per reason is not directly available from the Counter, so omit it
                     print(f"  {reason}: {count} events ({percentage:.1f}%)")
                 else:
                     logger.warning(f"Invalid count ({count}) found for exit reason '{reason}' in analyze_backtest_results.")
        elif total_trades_count == 0:
             print("  No trades to analyze exit reasons.")
        else:
             print("  Exit reason data missing or invalid in results.")
        # --- END FIX ---

        # --- Consecutive wins/losses analysis ---
        trade_list = results.get('trades')
        if trade_list and isinstance(trade_list, list):
            # Filter out potential non-dict entries if any (shouldn't happen with validation)
            valid_trade_list = [t for t in trade_list if isinstance(t, dict)]
            if valid_trade_list:
                current_streak = 0
                max_win_streak = 0
                max_loss_streak = 0
                current_streak_type = None

                first_trade_pnl = valid_trade_list[0].get('profit_loss', 0)
                if first_trade_pnl != 0: # Start streak only if not breakeven
                    current_streak = 1
                    current_streak_type = 'win' if first_trade_pnl > 0 else 'loss'
                else:
                     # Handle case where first trade is BE - start streak on next non-BE trade
                     pass

                for i in range(1, len(valid_trade_list)):
                    pnl = valid_trade_list[i].get('profit_loss', 0)
                    if pnl == 0: continue # Skip breakeven trades for streak calculation

                    is_win = pnl > 0
                    streak_type = 'win' if is_win else 'loss'

                    if current_streak_type is None: # Handle starting after initial BE trades
                         current_streak = 1
                         current_streak_type = streak_type
                    elif streak_type == current_streak_type:
                        current_streak += 1
                    else:
                        # Update max streak
                        if current_streak_type == 'win':
                            max_win_streak = max(max_win_streak, current_streak)
                        elif current_streak_type == 'loss': # Check explicitly for 'loss'
                            max_loss_streak = max(max_loss_streak, current_streak)

                        # Reset streak
                        current_streak = 1
                        current_streak_type = streak_type

                # Update max streak one more time for the final streak
                if current_streak_type == 'win':
                    max_win_streak = max(max_win_streak, current_streak)
                elif current_streak_type == 'loss':
                    max_loss_streak = max(max_loss_streak, current_streak)

                print(f"\nMax Winning Streak: {max_win_streak} events")
                print(f"Max Losing Streak: {max_loss_streak} events")
            else:
                 print("\nNo valid trade data for streak analysis.")
        else:
            print("\nTrade list missing or invalid for streak analysis.")


        # --- Monthly performance ---
        trade_list = results.get('trades')
        if trade_list and isinstance(trade_list, list):
            try:
                trades_df = pd.DataFrame(trade_list)
                # Ensure required columns exist and PnL is numeric
                if 'exit_time' in trades_df.columns and 'profit_loss' in trades_df.columns:
                    trades_df['exit_time'] = pd.to_datetime(trades_df['exit_time'], errors='coerce')
                    trades_df['profit_loss'] = pd.to_numeric(trades_df['profit_loss'], errors='coerce')
                    trades_df.dropna(subset=['exit_time', 'profit_loss'], inplace=True) # Drop rows with invalid time or PnL

                    if not trades_df.empty:
                        trades_df['month'] = trades_df['exit_time'].dt.strftime('%Y-%m')
                        monthly_perf = trades_df.groupby('month')['profit_loss'].sum()

                        if not monthly_perf.empty:
                             best_month = monthly_perf.idxmax()
                             worst_month = monthly_perf.idxmin()
                             print(f"\nMonthly Performance:")
                             print(f"  Best Month: {best_month} (${monthly_perf[best_month]:.2f})")
                             print(f"  Worst Month: {worst_month} (${monthly_perf[worst_month]:.2f})")
                        else:
                             print("\nNo monthly performance data available after grouping.")
                    else:
                         print("\nNo valid trade data for monthly performance analysis.")
                else:
                     print("\n'exit_time' or 'profit_loss' column missing for monthly performance.")
            except Exception as monthly_err:
                logger.error(f"Error calculating monthly performance: {monthly_err}", exc_info=True)
                print("\nError calculating monthly performance.")
        else:
            print("\nTrade list missing or invalid for monthly performance.")

    else: # No trades executed
        print("  No trades executed during this period.")

    print("="*50)

def generate_trade_report(results, output_file='trade_report.csv'):
    """
    Generate a detailed CSV report of all trades and append to existing report if it exists
    
    Args:
        results (dict): Backtest results
        output_file (str): Output CSV filename
    """
    try:
        if not results.get('trades'):
            print("No trades to report")
            return
        
        # Create directory if it doesn't exist
        directory = os.path.dirname(os.path.abspath(output_file))
        if directory and not os.path.exists(directory):
            os.makedirs(directory, exist_ok=True)
            print(f"Created directory: {directory}")
        
        # ÄNDERUNG: Konstante Startbilanz für alle Trades setzen
        fixed_start_balance = Z_config.start_balance_parameter  # Typischerweise 25 USD
        
        # ÄNDERUNG: Stelle sicher, dass alle Trades die korrekte Startbilanz haben
        if 'trades' in results and results['trades']:
            for trade in results['trades']:
                # Setze entry_balance auf die konstante Startbilanz
                trade['entry_balance'] = fixed_start_balance
                # Berechne exit_balance basierend auf der konstanten Startbilanz und dem Gewinn/Verlust
                trade['exit_balance'] = fixed_start_balance + trade['profit_loss']
        
        # Convert trades to DataFrame
        trades_df = pd.DataFrame(results['trades'])
        
        # Calculate return percentage
        # Innerhalb generate_trade_report, nach Konvertierung zu DataFrame
        trades_df['return_pct'] = (trades_df['profit_loss'] / fixed_start_balance) * 100 if fixed_start_balance > 0 else 0.0
        
        # Calculate trade duration
        trades_df['duration'] = pd.to_datetime(trades_df['exit_time']) - pd.to_datetime(trades_df['entry_time'])
        trades_df['duration_hours'] = trades_df['duration'].dt.total_seconds() / 3600
        
        # Convert datetime columns to string for CSV export
        trades_df['entry_time'] = pd.to_datetime(trades_df['entry_time']).dt.strftime('%Y-%m-%d %H:%M:%S')
        trades_df['exit_time'] = pd.to_datetime(trades_df['exit_time']).dt.strftime('%Y-%m-%d %H:%M:%S')
        
        # Check if file exists
        file_exists = os.path.isfile(output_file)
        
        if file_exists:
            # Read existing file
            try:
                existing_df = pd.read_csv(output_file)
                
                # ÄNDERUNG: Aktualisiere auch die bestehenden Daten mit der konstanten Startbilanz
                if 'entry_balance' in existing_df.columns:
                    existing_df['entry_balance'] = fixed_start_balance
                    # Berechne exit_balance neu, wenn profit_loss verfügbar ist
                    if 'profit_loss' in existing_df.columns:
                        existing_df['exit_balance'] = fixed_start_balance + existing_df['profit_loss']
                
                # Combine existing data with new data
                combined_df = pd.concat([existing_df, trades_df], ignore_index=True)
                
                # Remove potential duplicates based on key fields
                if 'symbol' in combined_df.columns:
                    combined_df = combined_df.drop_duplicates(
                        subset=['symbol', 'entry_time', 'exit_time', 'entry_price', 'exit_price'], 
                        keep='last'
                    )
                else:
                    combined_df = combined_df.drop_duplicates(
                        subset=['entry_time', 'exit_time', 'entry_price', 'exit_price'], 
                        keep='last'
                    )
                
                # Save combined data
                combined_df.to_csv(output_file, index=False)
                
                # Report results
                added_trades = len(combined_df) - len(existing_df)
                print(f"✅ Trade report updated: {added_trades} new trades added to {output_file}")
                print(f"   Total trades in report: {len(combined_df)}")
                
            except Exception as e:
                # Fallback if reading existing file fails
                print(f"Warning: Could not read existing file ({e}). Creating new file.")
                trades_df.to_csv(output_file, index=False)
                print(f"✅ Created new trade report with {len(trades_df)} trades: {output_file}")
        else:
            # Create new file
            trades_df.to_csv(output_file, index=False)
            print(f"✅ Created new trade report with {len(trades_df)} trades: {output_file}")
        
        # Verify file was created
        if os.path.exists(output_file):
            print(f"   File size: {os.path.getsize(output_file)} bytes")
        else:
            print(f"❌ Failed to create trade report {output_file}")
            
    except Exception as e:
        error_msg = f"Error generating trade report {output_file}: {e}"
        print(f"ERROR: {error_msg}")
        logging.error(error_msg)
        import traceback
        traceback.print_exc()
        
